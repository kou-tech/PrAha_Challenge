# 課題1

## A.

Dockerは、ソフトウェアを「コンテナ」という形でパッケージ化して動かすためのプラットフォームのことである。

アプリケーションを実行するために必要なコード、ライブラリ、設定ファイルなどを1つのパッケージにまとめることで、どの環境でも同じように動作させることができる。

コンテナはホストOSのカーネルを共有しながら独立した実行環境を提供するため、仮想マシンと比べて軽量で、起動も数秒で完了する。

主な用途として、開発環境の統一、テストの自動化、マイクロサービスの実装、アプリケーションのデプロイなどがある。

## A.

Dockerイメージは、Dockerコンテナを作るための設計図のようなものである。

アプリケーションを動かすために必要なOS、ライブラリ、設定、コードなどをすべて含んだ静的なファイルであり、このイメージを元にし、実際に動作する「コンテナ」を作成できる。

通常、イメージは「Dockerfile」というファイルから作成する。

## A.

Dockerコンテナは、ソフトウェアを実際に動かすための「実行環境」である。

どのマシンでも同じように動作し、コンテナ同士やホストの環境に影響を与えないため、独立性が高く、仮想マシンよりも少ないリソースで実行できる。

## A.

ベースイメージは、Dockerイメージを構築する際の「土台」となるものである。

アプリケーションを実行するための基本環境が整っており、そこに必要な設定やソフトウェアを追加して、独自のイメージを作成できる。

ベースイメージは主に次の2種類に分類される。

OSベースのイメージ

- `ubuntu`, `debian`, `alpine` など、軽量のLinuxディストリビューション。
- アプリケーションを動かすための基本的なOS環境を提供する

ランタイムベースのイメージ

- `node`, `python`, `java` など、特定のプログラミング言語やランタイム環境が事前にインストールされたもの。

また、「空のベースイメージ」という選択肢もあり、これを使用すると、必要最小限のコンポーネントだけを含む完全なミニマム環境を構築できる。

## A.

Dockerレジストリは、Dockerイメージを保存しておくための場所である。

イメージをクラウドやサーバー上にアップロードして、共有したり再利用したりするために使う。

Dockerレジストリには、主に次の２種類がある。

1. パブリックレジストリ
    - 誰でも使える公開のレジストリ。
    - 有名なのが「Docker Hub」である。公式のDockerイメージもここに置かれている。
2. プライベートレジストリ
    - 特定の人だけがアクセスできるレジストリ。
    - 企業やプロジェクト内で専用のイメージを管理するのに使うよ。
    - プライベートレジストリを提供するサービスには、次のようなものがある。
        - Amazon Elastic Container Registry (ECR)：AWSのレジストリサービス。
        - Google Container Registry (GCR)： Google Cloudのレジストリサービス。
        - Azure Container Registry (ACR)：Azureのレジストリサービス。

## A.

ビルドコンテキストは、Dockerイメージを作るときにDockerに送られる作業用フォルダやファイルの集まりのことである。。

簡単に言うと、「Dockerがイメージを作るために使う素材」のこと。

次のようなものがビルドコンテキストに含まれる。

- Dockerfile：イメージを作るための設計図。
- ソースコード：アプリケーションのコード。
- 設定ファイル：環境設定やコンフィグファイル。
- 必要なファイル：ライブラリや静的リソース（画像、CSSなど）。

ビルドコンテキストが大きすぎるといくつか問題が出てくる。

1. 不要なファイルもDockerに送られるので、無駄な時間がかかる。
2. 例えば、パスワードやAPIキーが含まれているファイルをうっかり送ってしまうと危険である。
3. 不要なファイルがイメージに含まれる可能性がある

後続の課題で説明する`.dockerignore`ファイルを使うと、特定のファイルやフォルダを除外することができる。

## A.

Dockerfileの中で複数のビルドステージを定義して、最終的なイメージに必要なものだけを残す方法である。

複数のステージを残すことで、不要なファイルをイメージに含めないようにしたり、イメージサイズを削減、開発環境やデバッグ用のツールを最終イメージから排除することができる。

```docker
# ステージ1: ビルド用
FROM node:20 AS builder

# 作業ディレクトリを作成
WORKDIR /app

# package.jsonをコピーして依存関係をインストール
COPY package.json ./
RUN npm install

# アプリのソースコードをコピーしてビルド
COPY . ./
RUN npm run build

# ステージ2: 実行用
FROM node:20-alpine AS runtime

# 作業ディレクトリを作成
WORKDIR /app

# ビルド成果物だけをコピー
COPY --from=builder /app/dist ./dist

# 必要な依存関係を再インストール（プロダクションモード）
COPY package.json ./
RUN npm install --production

# アプリの起動コマンド
CMD ["node", "dist/index.js"]

```

## A.

同じ環境を誰のマシンでも確実に再現できる。

環境構築の手順を完全に自動化できる。

環境による差異がなくなり、開発環境で動作確認したものが本番環境でもそのまま動く。

Dockerfileはコードとして管理できるため、変更履歴の追跡管理が可能。

## A.

Docker Composeは、複数のコンテナを効率的に管理・運用するための強力なツールである。

開発やデプロイメントのワークフローを大幅に簡素化し、複雑なアプリケーション環境の構築を容易にする。

具体的な例を挙げると、Webアプリケーション、データベース、キャッシュサーバー、バックグラウンドワーカーなど、複数のサービスで構成される現代的なアプリケーションがあった場合、Docker Composeを使用することで、これらすべてのサービスの設定と関係性を1つの設定ファイルで一元的に管理することができる。

Docker Composeの主な特徴は次の通りである。

- 複数のコンテナを一括で効率的に管理でき、起動・停止・再起動などの操作を簡単に行える
- 設定を一元化してYAML形式で管理できるため、チーム内での共有や版管理が容易になる
- 開発環境やテスト環境の構築を自動化でき、新しいメンバーの環境セットアップも迅速に行える
- コンテナ間の依存関係やネットワーク設定を明示的に定義でき、複雑なマイクロサービスアーキテクチャも管理しやすくなる
- 必要に応じて特定のサービスだけをスケールアップしたり、リソースの割り当てを調整したりすることが可能である

## A.

`.dockerignore`ファイルは、適切に設定することで、ビルドコンテキストから特定のファイルやディレクトリを除外し、ビルドの効率性を向上させ、セキュリティリスクを最小限に抑えることができる。

また、イメージサイズの最適化にも貢献し、デプロイメントの効率化にもつながる。

- ビルドに不要なファイル（例：`node_modules`、`.git`、`build/`、`dist/`）。これらは開発環境でのみ必要で、コンテナ内では再生成されるべきもの。
- 機密情報（例：`.env`、`.env.*`、`*.pem`、`*.key`、証明書ファイル）。これらの情報が誤ってイメージに含まれることで、セキュリティ上の脆弱性となる可能性がある。
- ローカル専用のファイル（例：`tests/`、`docs/`、`README.md`、`CHANGELOG.md`）。これらは本番環境では不要であり、イメージサイズを不必要に増大させる原因となる。
- 一時ファイルやシステムファイル（例：`.DS_Store`、`*.swp`、`Thumbs.db`、`*.log`）。これらはビルドプロセスにおいて何の価値も持たず、除外すべきものである。
- 必要に応じて例外設定（例：`!important.env`）。特定のファイルを意図的にビルドコンテキストに含める場合に使用する。

## A.
これはDockerのレイヤー構造と、パッケージマネージャーの動作が密接に関係しているためである。

Dockerのイメージは各コマンドごとに新しいレイヤーを作成し、それらが積み重なって最終的なイメージを形成する。

パッケージマネージャーの更新情報はキャッシュされるため、分割されたコマンドでは予期せぬバージョンの不一致が発生する可能性がある。

- `apt-get update`と`apt-get install`を1つの`RUN`コマンドにまとめることで、パッケージの更新情報とインストールが同一レイヤー内で実行され、一貫性が保たれる。これにより、キャッシュの問題を回避し、常に最新のパッケージがインストールされることが保証する。
- `apt-get clean`とキャッシュ削除でイメージを軽くすることは、本番環境での運用を考慮した重要な最適化する。不要なキャッシュファイルを削除することで、イメージサイズを大幅に削減し、デプロイメントの効率化とストレージコストの削減につながる。

## A.
`ENV`は、Dockerイメージ全体で永続的に有効な環境変数を定義するための命令である。この方法で設定された環境変数は、イメージのビルド時からコンテナの実行時まで一貫して利用可能であり、アプリケーションの設定や重要な実行時パラメータの管理に適している。

一方、`RUN export`は異なる特性を持つ。これは特定の`RUN`命令の実行スコープ内でのみ有効な一時的な環境変数を設定する方法である。この変数は、その`RUN`コマンドの実行が完了すると消失してしまう。

1. `ENV`で設定された環境変数は、イメージ全体のライフサイクルを通じて永続的に維持され、コンテナ実行時にもそのまま利用可能です。アプリケーションの動作に必要な設定値やグローバルな変数の定義に最適である。
2. `RUN export`による環境変数の設定は、その特定の`RUN`命令内でのみ有効な一時的なものである。この方法は、ビルドプロセス中の一時的な設定や、特定のコマンド実行時にのみ必要な変数の定義に使用される。
3. したがって、アプリケーションの実行時に必要となる重要な設定や永続的に保持したい変数は`ENV`を使用し、ビルドプロセス中だけで完結する一時的な設定には`RUN export`を使用することが推奨される。この使い分けにより、効率的で管理しやすいDockerイメージを作成することができる。

# 課題2

## A.

```docker
FROM node:16.14.2-alpine
WORKDIR /api
CMD ["npm", "run", "start"]
```

```bash
docker build -t nest-backend -f ./docker/backend/Dockerfile .
docker run -d \
  --name nest-backend-container \
  -p 3000:3000 \
  -v $(pwd)/nest-app:/api \
  nest-backend
docker start nest-backend-container
docker stop nest-backend-container
```

## A.

```docker
version: "3.7"

services:

  backend:
    build:
      context: .
      dockerfile: ./docker/backend/Dockerfile
    tty: true
    volumes:
      - type: bind
        source: ./nest-app
        target: /api
    ports:
      - "3000:3000"
```

```bash
docker-compose up -d
docker-compose down
```
